# Урок: Основы объектно-ориентированного программирования. Принципы ООП.
# Задание Ultra Lite:
#1. Создать свои классы
#2. Добавить методы в классы
#3. Использовать инкапсуляцию, наследование, полиморфизм


# Выполнение задания Ultra Lite:

#1. Создадим два родительских класса: один класс - это 2D-классические геометрические фигуры, из которого затем,
# применив принцип полиморфизма, создадим два других класса - расчет периметра и расчет площади,
# второй родительский класс - это любое натуральное число, для которого осуществляется проверка является или оно простым,
# затем, применив принцип наследования, создадим новый класс, который проверяет является ли какое-либо расположение цифр в заданном числе простым числом.

class Formulas_2D: # создание класса Formulas_2D
    '''
    Домументрирование класса.
    Класс Formulas_2D выводит по одному примеру из основных формул плоской геометрической фигуры,
    объект класса - это фигура.
    Для создания объекта класса Formulas_2D и вывода формул его периметра и площади необходимо указать один аргумент:
    тип фигуры и применить к объекту метод вывода формул: .formulas()
    Тип фигуры (аргумент type_figure) может быть один из: quadrat (квадрат), rectangle (прямоугольник),
    parallelogram (параллелограмм), rhombus (ромб), trapezoid (трапеция), triangle (треугольник), circle (окружность).
    '''
    def __init__(self, type_figure): # встроенный метод класса, инициализация
        self.figure = type_figure # аргумент, тип фигуры
        if self.figure not in ['circle', 'quadrat', 'rectangle', 'parallelogram', 'triangle', 'trapezoid', 'rhombus']:
            raise Exception ('Ошибка ввода аргументов') # если уловие True, то принудительно запустить исключение

    def __str__(self): # встроенный метод класса, что выводить на экран когда для вывода подается сам объект
        return f'Фигура {self.figure}'

    def formulas(self): #метод класса, вывод формул площади и периметра фигуры
        dict_formul = {'quadrat': 'P = 4 * a, S = a * a, где a - длина стороны, P - периметр, S - площадь',
                       'rectangle': 'P = 2*(a+b), S = a * b, где a,b - длины сторон, P - периметр, S - площадь',
                       'parallelogram': 'P = 2*(a+b), S = a(b) * h, где a,b - длины сторон, h - длина высоты опущенной на эту сторону, P - периметр, S - площадь',
                       'rhombus': 'P = 4 * a, S = a * h, где a - длина стороны, h - длина высоты опущенной на эту сторону, P - периметр, S - площадь',
                       'trapezoid': 'P = a+b+с+d, S = h*(a+b)/2, где a,b - длины оснований, h - длина высоты, P - периметр, S - площадь',
                       'triangle': 'P = a+b+с, S = (a * h)/2, где a - длина стороны, h - длина высоты опущенной на эту сторону, P - периметр, S - площадь',
                       'circle': 'P = 2*pi*R, S = pi * R^2, где R - радиус окружности, P - длина окружности, S - площадь'}
        return dict_formul[self.figure]



# проверка откуда запускается наш код, если True, то как отдельный скрипт и выполняется все, что ниже, если False, то
# импоритируется из файла .py как отдельный модуль, полностью или частично по обращению к его методам
if __name__ == '__main__':
      try: # далее код программы, который может вызвать исключение:
        # help(Formulas_2D) # вызов справки по созданному классу с его документацией
        figure = Formulas_2D('triangle') # определеяем объект класса
        #figure.figure = 'quadrat' # после применения инкапсуляции доступ к эти аргументам извне будет недоступен
        #figure._Formulas_2D__figure = 'quadrat' #если не применить инкапсуляцию к этим аргументам, то их можно изменить после определения объекта
        print(figure, figure.formulas()) #и тогда результат будет неверным, относительно исхоных входных параметров при определении объекта
      except: # если поймано исключение, то выдать следующее сообщение:
          print('Ошибка ввода аргумента, несоответсвующий тип фигуры, см help(Formulas_2D)')



class Prime_numbers: # создание класса Prime_numbers
    '''
    Домументрирование класса.
    Класс Prime_numbers проверяет является ли введеное число простым, объект класса - это число.
    Для создания объекта класса Prime_numbers необходимо указать один аргумент: натуральное (целое положительное) число.
    Справка:
    Простое число — натуральное (целое положительное) число, имеющее ровно два различных натуральных делителя — единицу
    и самого себя. Другими словами, число x является простым, если оно больше 1 и при этом делится без остатка только на 1 и на x.
    '''
    def __init__(self, n): # встроенный метод класса, инициализация
        self.__number = n
        if type(self.__number) != int or self.__number < 2:
            raise Exception ('Ошибка, введеное число не натуральное') # если уловие True, то принудительно запустить исключение

    def __str__(self): # встроенный метод класса, что выводить на экран когда для вывода подается сам объект
        return f'Натуральное число {self.__number}'

    def prime_number(self): #создаем функцию(метод класса) с именем prime_number
        if self.__number == 2 or self.__number == 3: #если число равно 2 или 3, то оно простое, тогда функция возвращает True
            return True #возврат значения True
        else:
            for i in range(2, int(self.__number/2)+1): #проверяем существует ли для данного числа целочисленный делитель от 2 до int(number/2), если делитель встретился, то сразу возврат значения False
                if self.__number % i == 0:
                    return False
            return True #если целочисленный делитель не обнаружен, то возвращается значение True (число простое)

if __name__ == '__main__':
      try: # далее код программы, который может вызвать исключение:
        #help(Prime_numbers) # вызов справки по созданному классу с его документацией
        num = Prime_numbers(10) # определеяем объект класса
        num.__number = 11 # после применения инкапсуляции доступ к эти аргументам извне будет недоступен
        # num.number = 11 #если не применить инкапсуляцию к этим аргументам, то их можно изменить после определения объекта
        print('\n', num, ' является простым? - ', num.prime_number(), sep = '') #и тогда результат будет неверным, относительно исхоных входных параметров при определении объекта
      except: # если поймано исключение, то выдать следующее сообщение:
          print('\nОшибка, введеное число не натуральное или меньше 2, см help(Prime_numbers)')